/*
 * generated by Xtext
 */
package org.archware.sosadl.generator

import com.google.inject.Injector
import java.math.BigInteger
import java.util.ArrayList
import java.util.LinkedHashMap
import java.util.List
import java.util.Map.Entry
import org.archware.sosadl.SosADLStandaloneSetupGenerated
import org.archware.sosadl.sosADL.Action
import org.archware.sosadl.sosADL.AnyAction
import org.archware.sosadl.sosADL.ArchitectureDecl
import org.archware.sosadl.sosADL.AskAssertion
import org.archware.sosadl.sosADL.AssertBehavior
import org.archware.sosadl.sosADL.AssertProtocol
import org.archware.sosadl.sosADL.Behavior
import org.archware.sosadl.sosADL.BehaviorDecl
import org.archware.sosadl.sosADL.BinaryExpression
import org.archware.sosadl.sosADL.BooleanType
import org.archware.sosadl.sosADL.ChooseBehavior
import org.archware.sosadl.sosADL.ChooseProtocol
import org.archware.sosadl.sosADL.ComplexName
import org.archware.sosadl.sosADL.DataType
import org.archware.sosadl.sosADL.DataTypeDecl
import org.archware.sosadl.sosADL.DoExprBehavior
import org.archware.sosadl.sosADL.DoExprProtocol
import org.archware.sosadl.sosADL.DoneBehavior
import org.archware.sosadl.sosADL.DoneProtocol
import org.archware.sosadl.sosADL.DutyDecl
import org.archware.sosadl.sosADL.EntityBlock
import org.archware.sosadl.sosADL.Expression
import org.archware.sosadl.sosADL.ForEachBehavior
import org.archware.sosadl.sosADL.ForEachProtocol
import org.archware.sosadl.sosADL.FunctionDecl
import org.archware.sosadl.sosADL.GateDecl
import org.archware.sosadl.sosADL.IdentExpression
import org.archware.sosadl.sosADL.IfThenElseBehavior
import org.archware.sosadl.sosADL.IfThenElseProtocol
import org.archware.sosadl.sosADL.Import
import org.archware.sosadl.sosADL.IntegerType
import org.archware.sosadl.sosADL.Library
import org.archware.sosadl.sosADL.MediatorDecl
import org.archware.sosadl.sosADL.NamedType
import org.archware.sosadl.sosADL.Protocol
import org.archware.sosadl.sosADL.ProtocolAction
import org.archware.sosadl.sosADL.ProtocolDecl
import org.archware.sosadl.sosADL.RangeType
import org.archware.sosadl.sosADL.ReceiveAction
import org.archware.sosadl.sosADL.ReceiveAnyProtocolAction
import org.archware.sosadl.sosADL.ReceiveProtocolAction
import org.archware.sosadl.sosADL.RecursiveCall
import org.archware.sosadl.sosADL.RepeatBehavior
import org.archware.sosadl.sosADL.RepeatProtocol
import org.archware.sosadl.sosADL.SendAction
import org.archware.sosadl.sosADL.SendProtocolAction
import org.archware.sosadl.sosADL.SequenceType
import org.archware.sosadl.sosADL.SoS
import org.archware.sosadl.sosADL.SosADL
import org.archware.sosadl.sosADL.SosADLFactory
import org.archware.sosadl.sosADL.SystemDecl
import org.archware.sosadl.sosADL.TellAssertion
import org.archware.sosadl.sosADL.TupleType
import org.archware.sosadl.sosADL.UnobservableBehavior
import org.archware.sosadl.sosADL.UntellAssertion
import org.archware.sosadl.sosADL.Valuing
import org.archware.sosadl.sosADL.ValuingBehavior
import org.archware.sosadl.sosADL.ValuingProtocol
import org.archware.sosadl.validation.typing.TypeChecker
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.resource.XtextResource
import org.eclipse.xtext.resource.XtextResourceSet

/**
 * Generates IOSTS code from the given SosADL model files on save.
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 * 
 * The SosADL2IOSTSGenerator inherits most of its compile methods from the SosADLPrettyPrinterGenerator
 * and overrides/adds methods for the STS generation.  
 */
class SosADL2IOSTSGenerator extends SosADLPrettyPrinterGenerator implements IGenerator {
    
    public static var DEBUG=false
    public static var DEBUG2=false
    public static var DEBUG3=false
    
    // global variables making the generation much easier
    // librariesMap contains all known libraries
    var LinkedHashMap<String,IOstsLibrary> librariesMap  // map of (name -> library)
    // importedMap contains all libraries to import in the current file
    var LinkedHashMap<String,IOstsLibrary> importedMap  // map of (name -> library)
    var IOstsType currentType                           // type currently generated
    var LinkedHashMap<String,IOstsType> currentTypesMap // map of (types -> typeDecl) currently generated
    var IOstsListOfFunctions currentListOfFunctions     // list of functions currently generated
    var IOstsLibrary currentLibrary                     // library currently generated
    var IOstsSystem currentSystem                       // system currently generated
    var IOstsProcess currentProcess                     // process currently generated
    var IOstsFunction currentFunction                   // function currently generated
    var int lastIOstsTypeNum
    var int lastDoExprResultNumber
    var int lastForEachVarNumber
    
    //FIXME: these two global variables should be avoided!
    var String globalFolderName = null 
    var IFileSystemAccess globalFsa = null
    var Resource globalResource = null
    
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		librariesMap = new LinkedHashMap()
	    importedMap = new LinkedHashMap()
	    currentType = null
	    currentTypesMap = null
	    currentListOfFunctions = null
	    currentLibrary = null
	    currentSystem = null
	    currentProcess = null
	    currentFunction = null
	    lastIOstsTypeNum = 0
	    lastDoExprResultNumber=0
	    lastForEachVarNumber=0
    
		globalFolderName = resource.URI.path.substring(0,resource.URI.path.lastIndexOf('/'))
		globalResource = resource
		globalFsa = fsa
		
		for (e : resource.allContents.toIterable.filter(SosADL)) {
			doGenerateOne(e)
		}
	}
	
	def void doGenerateOne(SosADL sfile) {
		// save the context of the previous compilation
		val LinkedHashMap<String,IOstsLibrary> _saved_importedMap = importedMap
		val IOstsType _saved_currentType = currentType
		val LinkedHashMap<String,IOstsType> _saved_currentTypesMap = currentTypesMap
		val IOstsSystem _saved_currentSystem = currentSystem
    	val IOstsProcess _saved_currentProcess = currentProcess
   	 	// ok: generate the iosts!
        var String resourceFilename = sfile.eResource.URI.trimFileExtension.lastSegment
        var String iostsFileName = resourceFilename+".iosts"
        System.out.println("Transforming '"+sfile.eResource.URI.lastSegment+"' into '"+iostsFileName+"'")
        importedMap = new LinkedHashMap()
        globalFsa.generateFile(iostsFileName, sfile.compile)
        // restore the context of the previous compilation
        importedMap = _saved_importedMap
        currentType = _saved_currentType
        currentTypesMap = _saved_currentTypesMap
        currentSystem = _saved_currentSystem
        currentProcess = _saved_currentProcess
    }
	 
	
	def SosADL loadSosADLResource(String resourceName) {
		var SosADL result
		var Injector injector = new SosADLStandaloneSetupGenerated().createInjector//AndDoEMFRegistration()
		var XtextResourceSet resourceSet = injector.getInstance(XtextResourceSet) as XtextResourceSet
		var URI uri = URI.createURI("platform:"+globalFolderName+'/'+resourceName+".sosadl")
    	resourceSet.addLoadOption(XtextResource.RESOURCE__URI, uri.toString)
		try {
			var Resource resource = resourceSet.getResource(uri, true)
			if (resource.getContents().empty) {
				if(DEBUG) System.err.println("Library '"+resourceName+"' at URI='"+resource.URI+"' is empty!")
    			result = null
    		} else {
    			if(DEBUG) System.err.println("Found library '"+resourceName+"' at URI='"+resource.URI+"'. ok.")
    			result = (resource.getContents().get(0) as SosADL)
    		}  		
    	} catch (Exception e) {
    		System.err.println("Warning! Library '"+resourceName+"' not found at uri '"+uri.path()+"'!")
    		result = null
    	}
		result
	}
	
	//=========================== model transformations
	
	/*
	 * Create a new NamedType EObject with given name
	 */
	def NamedType newNamedType(String name) {
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createNamedType()  // will create a NamedTypeImpl!
		result.setName(name)
		// since result is really a NamedTypeImpl, cast to a NamedType!
		(result as NamedType)
	}
	
	/*
	 * Transform a DoExpr into a Valuing EObject.
	 * From the AST of 'do Expression', we generate the AST for 'value _doExprResult# is dataType = Expression'
	 * where:
	 * - _doExprResult# is a unique variable name
	 * - dataType is the type of Expression
	 */

	 def ValuingProtocol newValuingFromDoExpr(DoExprProtocol doExpr) {
	 	val factory = SosADLFactory.eINSTANCE
	 	var result = factory.createValuingProtocol
	 	result.valuing = newValuingFromDoExpr_(doExpr.expression)
	 	result;
	 }
	 def ValuingBehavior newValuingFromDoExpr(DoExprBehavior doExpr) {
	 	val factory = SosADLFactory.eINSTANCE
	 	var result = factory.createValuingBehavior
	 	result.valuing = newValuingFromDoExpr_(doExpr.expression)
	 	result;
	 }

	 def Valuing newValuingFromDoExpr_(Expression doExpr) {
		// generate a new dumb variable
		lastDoExprResultNumber++
		val String dumbVarName="_doExprResult"+lastDoExprResultNumber
		val DataType datatype = TypeChecker.getType(doExpr)
		// create a Valuing
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createValuing()  // will create a ValuingImpl!
		result.setType(EcoreUtil.copy(datatype))
		result.setName(dumbVarName)
		result.setExpression(EcoreUtil.copy(doExpr))
		(result as Valuing)
	}
	
	/*
	 * Create a ComplexName out of the name of a IOstsConnection
	 * Since the name of a connection is already the concatenation of the elements of the ComplexName,
	 * one has to split this name and remove the added '::' to get each element of the ComplexName.
	 * Example: gate::connection has to be splitted in ComplexName(Name('gate'),Name('connection')) 
	 */
	def ComplexName newComplexNameFromString(String name) {
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createComplexName()  // will create a ComplexNameImpl?
		var complexname = name.split("::")
		for (n : complexname) {
			result.getName().add(n)
		}
		result
	}
	
	/*
	 * Create an ChooseProtocol (choose {action1} or {action2} ...)
	 * out of the given list of connections.
	 * From the list of declared connections in the current gate/duty, 
	 * we generate the AST for 'choose {action1} or {action2}'
	 * where:
	 * - each declared connection <c> gives one or two actions.
	 * - if one connection <c.name> has mode 'in', the generated action is 'via <c.name> receive any'. 
	 * - if one connection <c.name> has mode 'out', the generated action is 'via <c.name> send any'. 
	 * - if one connection <c.name> has mode 'inout', two actions are gerenated:
	 *   'via <c.name> receive any' and 'via <c.name> send any'. 
	 */
	def ChooseProtocol newChooseProtocolActionFromConnections(LinkedHashMap<String,IOstsConnection> connectionsMap) {
		// create a Valuing
		val factory = SosADLFactory.eINSTANCE
		var result = factory.createChooseProtocol()  // will create a ChooseProtocolImpl!
		for (c : connectionsMap.values) {
			// create the appropriate(s) action(s) and make it a new branch
			if (c.mode == 'in' || c.mode == 'inout') {
				// connection mode is 'in' or 'inout': create a branch with 'via <c.name> receive any'
				// make a ComplexName out of the name of the connection
				var ComplexName conectionName=newComplexNameFromString(c.name)
				// create a new ReceiveAnyProtocolAction which is a ProtocolActionSuite
				var actionSuite = factory.createReceiveAnyProtocolAction()
				// create a new ProtocolAction
				var action = factory.createProtocolAction()
				action.setComplexName(conectionName)
				action.setSuite(actionSuite)
				// create a new Branch of the ChooseProtocol, and add the action to it
			    var branch = factory.createProtocol()
			    branch.getStatements().add(action)
			    // add the branch to the ChooseProtocol
			    result.getBranches().add(branch)
			}
			if (c.mode == 'out' || c.mode == 'inout') {
				// connection mode is 'out' or 'inout': create a branch with 'via <c.name> send any'
				// make a ComplexName out of the name of the connection
				var ComplexName conectionName=newComplexNameFromString(c.name)
				// create a FinalExpression Any ('any')
				var anyExpression = factory.createAny()
				// create a new ReceiveAnyProtocolAction which is a ProtocolActionSuite
				var actionSuite = factory.createSendProtocolAction()
				actionSuite.setExpression(anyExpression)
				// create a new ProtocolAction
				var action = factory.createProtocolAction()
				action.setComplexName(conectionName)
				action.setSuite(actionSuite)
			    // create a new Branch of the ChooseProtocol, and add the action to it
			    var branch = factory.createProtocol()
			    branch.getStatements().add(action)
			    // add the branch to the ChooseProtocol
			    result.getBranches().add(branch)
			}
		}
		result
	}
	
    def newIoSTSFunction(FunctionDecl f) {
    	var iof = new IOstsFunction(f.name.toString)
    	//iof.setData(f.dataName, computeIOstsType(f.dataTypeName))
    	iof.setData(f.data.name, computeIOstsType(f.data.type))
    	for (p : f.parameters) {
    		iof.addFormalParameter(p.name, computeIOstsType(p.type))
    	}
    	iof.returnType = computeIOstsType(f.type)
    	for (v : f.valuing) {
    		iof.addValuing(v)
    	}
    	iof.returnExpression = f.expression
    	iof
    }
	
	/* Create an IfThenElseBehavior 'if (Expression) then {BehaviorStatement*}'
	 * out of the given list of BehaviorStatements where:
	 * - the ask statement which is the AskAssertion, containing the condition=Expression of if(condition)
	 * - the next statements, if any, are the BehaviorStatement to be put inside 'then{}' 
	 * The SoSADL grammar does not allow a Behavior without statements.
	 * Thus, in case the ifThenStatements is empty, a Done statement is added to it.
	 * 
	 * Note: unused since we do not use anymore this model transformation to translate AskAssertion
	 *       into an IoSTS transition.
	 *
	def IfThenElseBehavior newIfThenElseBehaviorFromAskAssertionAndBehaviorStatements(AskAssertion ask, ArrayList<BehaviorStatement> ifThenStatements) {
		// create a Behavior which will contain the ifThenStatements
		val factory = SosADLFactory.eINSTANCE
		var ifTrueBehavior = factory.createBehavior()
		if (ifThenStatements.empty) {
			val done = factory.createDone()
			ifThenStatements.add(done)
		}
		ifTrueBehavior.getStatements().addAll(ifThenStatements)
		// create an IfThenElseBehavior
		var result = factory.createIfThenElseBehavior() // will create a IfThenElseBehaviorImpl!
		result.setCondition(ask.expression)
		result.setIfTrue(ifTrueBehavior)
		result
	}
	*/
	
	/* Create an IfThenElseProtocol 'if (Expression) then {ProtocolStatement*}'
	 * out of the given list of ProtocolStatements where:
	 * - the ask statement which is the AskAssertion, containing the condition=Expression of if(condition)
	 * - the next statements, if any, are the ProtocolStatement to be put inside 'then{}' 
	 * The SoSADL grammar does not allow a Protocol without statements.
	 * Thus, in case the ifThenStatements is empty, a Done statement is added to it.
	 * 
	 * Note: unused since we do not use anymore this model transformation to translate AskAssertion
	 *       into an IoSTS transition.
	 *
	def IfThenElseProtocol newIfThenElseProtocolFromAskAssertionAndProtocolStatements(AskAssertion ask, ArrayList<ProtocolStatement> ifThenStatements) {
		// create a Protocol which will contain the ifThenStatements
		val factory = SosADLFactory.eINSTANCE
		var ifTrueProtocol = factory.createProtocol()
		if (ifThenStatements.empty) {
			val done = factory.createDone()
			ifThenStatements.add(done)
		}
		ifTrueProtocol.getStatements().addAll(ifThenStatements)
		// create an IfThenElseProtocol
		var result = factory.createIfThenElseProtocol() // will create a IfThenElseProtocolImpl!
		result.setCondition(ask.expression)
		result.setIfTrue(ifTrueProtocol)
		result
	}
	*/
	
    
    //=========================== compilation
	    
    override def compile(Import i) {
    	var IOstsLibrary library = null
    	if (librariesMap.containsKey(i.importedLibrary)) {
    		if(DEBUG) System.err.println("Library '"+i.importedLibrary+"' already compiled, and imported. ok.")
    		library = librariesMap.get(i.importedLibrary)
     	} else if (i.importedLibrary.toLowerCase.equals("base")) {
			// FIXME!
			if(DEBUG) System.err.println("TODO: Define 'predefined' library '"+i.importedLibrary+"'!")
	    	library = null
    	} else {
    		val SosADL sresource=loadSosADLResource(i.importedLibrary)
    		if (sresource == null) {
    			System.err.println("Warning! Cannot import '"+i.importedLibrary+"': source file not found!")
    		} else {
    			if(DEBUG) System.err.println("Importing library '"+i.importedLibrary+"'...")
    			doGenerateOne(sresource)
    			if (librariesMap.containsKey(i.importedLibrary)) {
    				if(DEBUG) System.err.println("Library '"+i.importedLibrary+"' compiled, and imported. ok.")
    			} else {
    				System.err.println("Warning! Library '"+i.importedLibrary+"' compiled, but not imported!")
    			}
    			library = librariesMap.get(i.importedLibrary)
    		}
    	}
    	if (library != null) {
    		importedMap.put(i.importedLibrary, library)
    	}
    	super.compile(i)
    }
	
	override def compile(Library l) {
		currentLibrary = new IOstsLibrary(l.name)
		currentLibrary.importedMap.putAll(importedMap)
		val result = super.compile(l)
		if (currentLibrary != null) {
			librariesMap.put(l.name, currentLibrary)
		}
		currentLibrary = null
		result
	}
	
	override def compile(SoS s) {
		currentLibrary = new IOstsLibrary(s.name)
		val result = super.compile(s)
		if (currentLibrary != null) {
			importedMap.put(s.name, currentLibrary)
		}
		currentLibrary = null
		result
	}
	
	override def compile(EntityBlock e) {
		currentSystem = null
		
		currentTypesMap = new LinkedHashMap()
		var String datatypes =
		'''
		«IF !e.datatypes.empty»
		«FOR d : e.datatypes»
      		«d.compile»
    	«ENDFOR»
    	«ENDIF»
    	'''
    	currentLibrary.typesMap.putAll(currentTypesMap)
    	
		currentListOfFunctions = new IOstsListOfFunctions()
		var String functions =
		'''
		«IF !e.functions.empty»
      	«FOR f : e.functions»
      		«f.compile»
    	«ENDFOR»
    	«ENDIF»
    	'''
	    currentLibrary.functions.addAll(currentListOfFunctions)
	    
        currentListOfFunctions = null
        currentTypesMap=null
        
    	'''
		«datatypes»
		«functions»
		
        «FOR s : e.systems»
      		«s.compile»
    	«ENDFOR»
    	«FOR m : e.mediators»
      		«m.compile»
    	«ENDFOR»
    	«FOR a : e.architectures»
      		«a.compile»
    	«ENDFOR»
    	'''
	}
	
	override def compile(DataTypeDecl d) {
		var IOstsType t
		if (d.datatype == null) {
			if(DEBUG2) System.err.println("Warning! type definition of '" + d.name + "' null! Assuming 'integer'...")
			t = new IOstsIntType()
		} else {
			t = computeIOstsType(d.datatype)
		}
		// put this type in currentTypesMap allow function declarations to get it
		currentTypesMap.put(d.name, t)
		// get list of functions
		for (f:d.functions) {
			t.functions.add(newIoSTSFunction(f))
		}
		// now that the type is completed with functions, put the type again in currentTypesMap
		currentTypesMap.put(d.name, t)
		super.compile(d)
	}
    
    override def compile(FunctionDecl f) {
    	if (currentListOfFunctions != null) {
    		currentListOfFunctions.add(newIoSTSFunction(f))
    	}
    	super.compile(f)
    }
	
	override def compile(SystemDecl s) {
		currentSystem = new IOstsSystem(s.name)
		currentTypesMap = new LinkedHashMap()
		val result = super.compile(s)
		currentSystem.typesMap.putAll(currentTypesMap)
		currentTypesMap = null

		// add system if it's not empty
		if (! currentSystem.empty) {
			currentLibrary.addSystem(currentSystem)
		}
		currentSystem = null
		result
	}
    
    override def compile(MediatorDecl m) {
		currentSystem = new IOstsSystem(m.name)
		currentTypesMap = new LinkedHashMap()
		val result = super.compile(m)
		currentSystem.typesMap.putAll(currentTypesMap)
		currentTypesMap = null

		// add system if it's not empty
		if (! currentSystem.empty) {
			currentLibrary.addSystem(currentSystem)
		}
		currentSystem = null
		result
	}
    
    override def compile(ArchitectureDecl a) {
		currentSystem = new IOstsSystem(a.name)
		currentTypesMap = new LinkedHashMap()
		val result = super.compile(a)
		currentSystem.typesMap.putAll(currentTypesMap)
		currentTypesMap = null

		// add system if it's not empty
		if (! currentSystem.empty) {
			currentLibrary.addSystem(currentSystem)
		}
		currentSystem = null
		result
	}
    
    override def compile(GateDecl g){
    	for (c : g.connections) {
	    	if (DEBUG2) {
	    		System.err.println("Declaring gate connection = '"+g.name+"::"+c.name+"'")
	    	}
	        val name=g.name+"::"+c.name
	        val IOstsType type = computeIOstsType(c.valueType)
	        val typeName = nameOfIOstsType(type) //finalNameOfIOstsType(nameOfIOstsType(type))
            val connection = new IOstsConnection(name, typeName, c.mode.toString)
	        currentSystem.addConnection(connection)
	    }
	    super.compile(g)
	}

	
	override def compile(DutyDecl d){
		for (c : d.connections) {
        	if (DEBUG2) {
	    		System.err.println("Declaring duty connection = '"+d.name+"::"+c.name+"'")
	    	}
            val name=d.name+"::"+c.name
            val IOstsType type = computeIOstsType(c.valueType)
            val typeName = nameOfIOstsType(type) //finalNameOfIOstsType(nameOfIOstsType(type))
            val connection = new IOstsConnection(name, typeName, c.mode.toString)
	        currentSystem.addConnection(connection)
	    }
        super.compile(d)
    }
    
    //---------------- Compilation of Protocol and Behavior is special
    
    override def compile(ProtocolDecl p) {
        var IOstsTransition firstTransition = initTransition("true")
        firstTransition.setComment("FIXME: system/mediator/architecture parameters may change this guard!")
        currentProcess = new IOstsProcess(p.name)
        currentProcess.addTransition(firstTransition)
        computeSTS(firstTransition.toState(),p.body)
        currentSystem.addProcess(currentProcess)
        '''protocol «p.name» is «currentProcess»'''
    }
    
    override def compile(BehaviorDecl b){
        var IOstsTransition firstTransition = initTransition("true")
        firstTransition.setComment("FIXME: system/mediator/architecture parameters may change this guard!")
        currentProcess = new IOstsProcess(b.name)
        currentProcess.addTransition(firstTransition)
        computeSTS(firstTransition.toState(),b.body)
        currentSystem.addProcess(currentProcess)
        '''behavior «b.name» is «currentProcess»'''
    }
    
    /* TODO! Generate the STS in place of the architecture behavior
	def compile(ArchBehaviorDecl a)'''
    behavior «a.name» is compose {
      «FOR c:a.constituents»
        «c.compile»
      «ENDFOR»
    } binding {
      «a.bindings.compile»
    }
	'''
	*/
	
	// get and register type of value
	override def compile(Valuing v){
	  registerValuing(v)
	  super.compile(v)
	}
	
	// register name and type of Valuing
	def registerValuing(Valuing v) {
		if (currentProcess == null) {
			// Nothing to do! This Valuing occurs inside a FunctionDecl
		} else {
			// the Valuing to register occurs inside a Process (Protocol or Behavior) 	
			if (v.type == null) {
				currentProcess.addVariable(v.name)
			} else {
				val type = computeIOstsType(v.type)
				val typeName = nameOfIOstsType(type)
				currentProcess.addVariable(v.name, typeName)//finalNameOfIOstsType(typeName))
			}
		}
	}
	
    
    //=========================== Generation of the STS
    
    /*
     * Returns an init transition: from 0 to 1, with given guard.
     * Shall be added before any other in a Behavior or Protocol.
     * The first transition has no action, not assignments.
     * A default comment is added, but can be changed. 
     */
    def IOstsTransition initTransition(String guard) {
    	var IOstsTransition firstTransition = new IOstsTransition(0,1)
    	firstTransition.setInit(true)
    	firstTransition.setGuard(guard)
    	firstTransition.setComment("first transition") // default comment, can be changed later
	    firstTransition
    }
    
    /*
     * All computeSTS() functions return the final states of the STS
     * according to the behavior starting at startState.
     */
    /*
     * - computeSTS for a Behavior (which is a sequence of BehaviorStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Behavior b) {
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        var boolean previousIsValuing=false
        var int previousStartState=0
        var int istatement=0
        var int nstatements=b.statements.length
        while(istatement < nstatements) {
        	var s=b.statements.get(istatement)
            if (! first) { // && finalStates.length >= 2) {
            	// NEW version: concatenation for sequentiality is generated between two statements
            	// ONLY when the first statement ends with at least 2 final states.
            	if (finalStates.size == 1) {
            		state=finalStates.get(0)
           		} else { // finalStates.length >= 2
                	state=currentProcess.newState()
	                var i=0
	                while (i < finalStates.size) {
	                    var IOstsTransition concatenation = new IOstsTransition(finalStates.get(i),state) //tau
	                    concatenation.setComment("Concatenation (sequentiality)")
	                    currentProcess.addTransition(concatenation)
	                    //System.out.println("Added concatenation transition: from="+finalStates.get(i)+", to="+state)
	                    i = i+1
	                }
                }
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            if (s instanceof ValuingBehavior) {
            	if (previousIsValuing) {
            		// adding a assignment to transition from state to finalStates.get(0)
            		// instead of creating a new transition
            		state = previousStartState
            		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, final(0)="+finalStates.get(0)+")")}
            		finalStates = computeSTS(state, s.valuing, finalStates.get(0), "Valuing")
            		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	} else {
               		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, 0)")}
            		finalStates = computeSTS(state, s.valuing, 0, "Valuing")
               		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	}
            	previousIsValuing = true
            } else {
            	previousIsValuing = false
            	/* OLD version with model transformation of AskAssertion into IfThenElseBehavior
            	if (s instanceof AskAssertion) {
            		// an AskAssertion is transformed into an IfThenElseBehavior statement
            		// where:
            		// - the AskAssertion expression becomes the condition of the IfThenElseBehavior
            		// - all remaining statements following the AskAssertion become the IfThen statements
            		var ArrayList<BehaviorStatement> remaining=newArrayList()
            		istatement++
            		while (istatement < nstatements) {
            			remaining.add(b.statements.get(istatement))
            			istatement++
            		}
            		var ifthen=newIfThenElseBehaviorFromAskAssertionAndBehaviorStatements(s, remaining)
            		finalStates = computeSTS(state, ifthen, "AskAssertion transformed into IfThenElseBehavior")
            	} else {
            		finalStates = computeSTS(state, s)	
            	}
            	*/
            	finalStates = computeSTS(state, s)
           	}
            first=false
            previousStartState=state
            if (DEBUG3) {System.err.println("END LOOP: state="+state+", previousStartState="+previousStartState+", final(0)="+finalStates.get(0))}
            istatement++
        }
        finalStates
    }
    
    /*
     * - computeSTS for a Protocol (which is a sequence of ProtocolStatement).
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Protocol b){
        var int state=startState
        var ArrayList<Integer> finalStates = newArrayList()
        var boolean first=true
        var boolean previousIsValuing=false
        var int previousStartState=0
        var int istatement=0
        var int nstatements=b.statements.length
        while(istatement < nstatements) {
        	var s=b.statements.get(istatement)
        	if (! first) {
            	// NEW version: concatenation for sequentiality is generated between two statements
            	// ONLY when the first statement ends with at least 2 final states.
            	if (finalStates.size == 1) {
            		state=finalStates.get(0)
           		} else { // finalStates.length >= 2
                	state=currentProcess.newState()
	                var i=0
	                while (i < finalStates.size) {
	                    var IOstsTransition concatenation = new IOstsTransition(finalStates.get(i),state) //tau
	                    concatenation.setComment("Concatenation (sequentiality)")
	                    currentProcess.addTransition(concatenation)
	                    //System.out.println("Added concatenation transition: from="+finalStates.get(i)+", to="+state)
	                    i = i+1
	                }
                }
            }
            // in a sequence of statements, only the last statement can have multiple final states
            // we just assume it's true!
            if (s instanceof ValuingProtocol) {
            	if (previousIsValuing) {
            		// adding a assignment to transition from state to finalStates.get(0)
            		// instead of creating a new transition
            		state = previousStartState
            		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, final(0)="+finalStates.get(0)+")")}
            		finalStates = computeSTS(state, s.valuing, finalStates.get(0), "Valuing")
            		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	} else {
            		if (DEBUG3) {System.err.println("CALLING computeSTS(state="+state+", s, 0)")}
            		finalStates = computeSTS(state, s.valuing, "Valuing")
            		if (DEBUG3) {System.err.println("RESULT final(0)="+finalStates.get(0))}
            	}
            	previousIsValuing = true
            } else {
            	previousIsValuing = false
            	/* OLD version with model transformation of AskAssertion into IfThenElseProtocol
            	if (s instanceof AskAssertion) {
            		// an AskAssertion is transformed into an IfThenElseProtocol statement
            		// where:
            		// - the AskAssertion expression becomes the condition of the IfThenElseProtocol
            		// - all remaining statements following the AskAssertion become the IfThen statements
            		var ArrayList<ProtocolStatement> remaining=newArrayList()
            		istatement++
            		while (istatement < nstatements) {
            			remaining.add(b.statements.get(istatement))
            			istatement++
            		}
            		var ifthen=newIfThenElseProtocolFromAskAssertionAndProtocolStatements(s, remaining)
            		finalStates = computeSTS(state, ifthen, "AskAssertion transformed into IfThenElseProtocol")
            	} else {
            		finalStates = computeSTS(state, s)	
            	}
            	*/
            	finalStates = computeSTS(state, s)
           	}
            first=false
            previousStartState=state
            if (DEBUG3) {System.err.println("END LOOP: state="+state+", previousStartState="+previousStartState+", final(0)="+finalStates.get(0))}
            istatement++
        }
        finalStates
    }
    
    /*
     * - computeSTS for a DoExpr statement: transform to a Valuing!
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, DoExprProtocol r){
    	val ValuingProtocol v = newValuingFromDoExpr(r)
    	computeSTS(startState, v.valuing, "DoExpr")
    }
    def dispatch ArrayList<Integer> computeSTS(int startState, DoExprBehavior r){
    	val ValuingBehavior v = newValuingFromDoExpr(r)
    	computeSTS(startState, v.valuing, "DoExpr")
    }
    
    /*
     * - computeSTS for a Valuing statement, not following a previous Valuing
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Valuing v, String comment){
    	computeSTS(startState, v, 0, comment)
    }
    
    /*
     * - computeSTS for a Valuing statement, may be following a Valuing statement.
     */
    def ArrayList<Integer> computeSTS(int startState, Valuing v, int finalState, String comment){
    	var int final
    	var IOstsTransition valuing
    	if (finalState == 0) {
    		final=currentProcess.newState()
        	valuing = new IOstsTransition(startState,final)
        } else {
        	final=finalState
        	if (DEBUG3) {
        		System.err.println("CALLING getTransition(startState="+startState+", final="+final+")")
        	}
        	valuing = currentProcess.getTransition(startState,final)
        	if (valuing == null) {
        		System.err.println("ERROR! Transition from="+startState+" to="+final+" not found!")
        	}
        }
        //valuing.addAssignment(v.compile.toString) // v.compile.toString hields SosADL syntax
        registerValuing(v)
        valuing.addAssignment(v.name+" := "+v.expression.compile)
        valuing.setComment(comment)
        currentProcess.addTransition(valuing)
        //System.out.println("Added valuing transition: from="+startState+", to="+final)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a Send/Receive Behavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, Action a){
        val int final=currentProcess.newState()
        var IOstsTransition action = new IOstsTransition(startState,final)
        var String channel=a.complexName.compile.toString
        if (DEBUG2) System.out.println("Behavior Action: Searching channel '"+channel+"' among all known connections")
        val IOstsConnection connection=currentSystem.getConnection(channel)
        if (connection == null) {
            System.err.println("Warning! Channel '"+channel+"' not declared for this behavior! Ignoring statement...")
            System.err.println("         Known channels are:")
            System.err.print("- Known channels are:")
            for (c : currentSystem.connectionsMap.entrySet) {
            	System.err.print(" '"+c.key+"'")
            }
            System.err.println(".")
        } else if (a.suite instanceof SendAction) {
            val parameter=currentProcess.newParameter()
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
            }
            else if (connection.mode == "out") {
            	if (! currentProcess.outputMap.containsKey(channel)) {
                	currentProcess.addOutput(channel, connection.typeName)
                	if (DEBUG2) System.out.println("Added channel '"+channel+"' to output connections")
            	}           
            }
            action.setGuard(parameter+" = "+(a.suite as SendAction).expression.compile)
            action.setAction("via "+channel+" send "+parameter)
            action.setComment("Send action")
            currentProcess.addParameter(parameter,connection.typeName)
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAction) {
            val variable=(a.suite as ReceiveAction).variable
            val parameter=variable+"_data"
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
            }
            else if (connection.mode == "in") {
	            if (! currentProcess.inputMap.containsKey(channel)) {
	                currentProcess.addInput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input connections")
	            }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, connection.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, connection.typeName)
            }
            action.setAction("via "+channel+" receive "+parameter)
            action.addAssignment(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }
    
    /*
     * utility function: get the name of the gate or duty in a AnyAction.
     * This function returns a valid gate/duty name only if the given AnyAction
     * occurs in a protocol of a gate/duty!
     */
    def String getNameOfGateOrDuty(AnyAction a) {
    	var gd = a.eContainer
    	var name=""
    	while(name == "") {
    		switch gd {
    			GateDecl: name = (gd as GateDecl).name
    			DutyDecl: name = (gd as DutyDecl).name
    			default: gd = gd.eContainer
    		}
    		if (gd == null) {
    			name = "unknown"
    		}
    	}
    	name
    }
    /*
     * utility function: get the name of the gate or duty in a ProtocolAction.
     * This is needed because the type-checker does not allow to specify the gate or duty
     * name in the connection name.
     */
    def String getNameOfGateOrDuty(ProtocolAction a) {
    	var gd = a.eContainer
    	var name=""
    	while(name == "") {
    		switch gd {
    			GateDecl: name = (gd as GateDecl).name
    			DutyDecl: name = (gd as DutyDecl).name
    			default: gd = gd.eContainer
    		}
    		if (gd == null) {
    			name = "unknown"
    		}
    	}
    	name
    }

    /*
     * - computeSTS for a Send/Receive Protocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ProtocolAction a){
        val int final=currentProcess.newState()
        var IOstsTransition action = new IOstsTransition(startState,final)
        var String channel=a.complexName.compile.toString
        if (channel.split('::').size < 2) {
            // We are in the case of a connection name that does not include the gate's or duty's name.
            // This happens in ProtocolAction occurring in guarantee/assume protocols of GateDecl/DutyDecl:
            // the type-checker only accept connection without the prefix gateName:: or dutyName::
            // Example: "via connection1 receive any" but not "via gate1::connection1 receive any"
            // So we must retrieve the gate or duty name in the ProtocolAction container.
            channel=a.getNameOfGateOrDuty+"::"+a.complexName.compile.toString
        }
        if (DEBUG2) System.out.println("ProtocolAction: Searching channel '"+channel+"' among all known connections")
        val IOstsConnection connection=currentSystem.getConnection(channel)
        if (connection == null) {
            System.err.println("Warning! Channel '"+channel+"' not declared for this protocol! Ignoring statement...")
            System.err.print("- Known channels are:")
            for (c : currentSystem.connectionsMap.entrySet) {
            	System.err.print(" '"+c.key+"'")
            }
            System.err.println(".")
        } else if (a.suite instanceof SendProtocolAction) {
            val parameter=currentProcess.newParameter()
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
            }
            else if (connection.mode == "out") {
	            if (! currentProcess.outputMap.containsKey(channel)) {
	                currentProcess.addOutput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to output connections")
	            }
            }
            if ((a.suite as SendProtocolAction).expression.compile.toString == "any") {
                /* FIXME: send any:
                 * - option 1 "pas de if": ANY_typeConnection est une constante qui doit etre definie
                 *     action.setAction(channel+"!(ANY_typeConnection)")
                 *     currentProcess.addParameter(parameter,connection.typeName)
                 * - option 2 "avec if en affectant au parametre une constante ANY_typeConnection" (au hasard?)
                 *     action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                 *     action.setAction(channel+"!("+parameter+")")
                 *     currentProcess.addParameter(parameter,connection.typeName)
                 */
                action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                action.setAction("via "+channel+" send "+parameter)
                currentProcess.addParameter(parameter,connection.typeName)
                action.setComment("Send any action. Note: any is a random value")
            } else {
                // send some expression
                action.setGuard(parameter+" = "+(a.suite as SendProtocolAction).expression.compile)
                action.setAction("via "+channel+" send "+parameter)
                currentProcess.addParameter(parameter,connection.typeName)
                action.setComment("Send action")
            }
            //System.out.println("Added send transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveProtocolAction) { 
            val variable=(a.suite as ReceiveProtocolAction).variable
            val parameter=variable+"_data"
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
            }
            else if (connection.mode == "in") {
	            if (! currentProcess.inputMap.containsKey(channel)) {
	                currentProcess.addInput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input connections")
	            }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, connection.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, connection.typeName)
            }
            action.setAction("via "+channel+" receive "+parameter)
            action.addAssignment(variable+" := "+parameter)
            action.setComment("Receive action")
            //System.out.println("Added receive transition: from="+startState+", to="+final)
        } else if (a.suite instanceof ReceiveAnyProtocolAction) {
            val variable="any_s"+startState
            val parameter=variable+"_data"
            if (connection.mode == "inout") {
                if (! currentProcess.inoutputMap.containsKey(channel)) {
                    currentProcess.addInoutput(channel, connection.typeName)
                    if (DEBUG2) System.out.println("Added channel '"+channel+"' to inoutput connections")
                }
            }
            else if (connection.mode == "in") {
	            if (! currentProcess.inputMap.containsKey(channel)) {
	                currentProcess.addInput(channel, connection.typeName)
	                if (DEBUG2) System.out.println("Added channel '"+channel+"' to input connections")
	            }
            }
            if (! currentProcess.parametersMap.containsKey(parameter)) {
                currentProcess.addParameter(parameter, connection.typeName)
            }
            if (! currentProcess.variablesMap.containsKey(variable)) {
                currentProcess.addVariable(variable, connection.typeName)
            }
            action.setAction("via "+channel+" receive "+parameter)
            action.addAssignment(variable+" := "+parameter)
            action.setComment("Receive any action")
            //System.out.println("Added receive any transition: from="+startState+", to="+final)
        }
        currentProcess.addTransition(action)
        newArrayList(final)
    }

    /*
     * - computeSTS for a IfThenElseBehavior statement, without comment
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseBehavior i){
    	computeSTS(startState, i, "IfThenElseBehavior")
    }
    
    /*
     * - computeSTS for a IfThenElseBehavior statement, with comment
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseBehavior i, String comment){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var IOstsTransition ifTrue = new IOstsTransition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment(comment+" (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var IOstsTransition ifFalse = new IOstsTransition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment(comment+" (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }
    
    /*
     * - computeSTS for a IfThenElseBehavior statement, without comment
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseProtocol i){
    	computeSTS(startState, i, "IfThenElseProtocol")
    }

    /*
     * - computeSTS for a IfThenElseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, IfThenElseProtocol i, String comment){
        var ArrayList<Integer> finalStates = newArrayList()
        // then required
        val int finalIfTrue=currentProcess.newState()
        var IOstsTransition ifTrue = new IOstsTransition(startState,finalIfTrue)
        ifTrue.setGuard(i.condition.compile.toString)
        ifTrue.setComment(comment+" (true case)")
        currentProcess.addTransition(ifTrue)
        //System.out.println("Added ifTrue transition: from="+startState+", to="+finalIfTrue)
        finalStates.addAll(computeSTS(finalIfTrue, i.ifTrue))
        // else optional
        if (i.ifFalse != null) {
            val int finalIfFalse=currentProcess.newState()
            var IOstsTransition ifFalse = new IOstsTransition(startState,finalIfFalse)
            ifFalse.setGuard("not "+i.condition.compile.toString)
            ifFalse.setComment(comment+" (false case)")
            currentProcess.addTransition(ifFalse)
            //System.out.println("Added ifFalse transition: from="+startState+", to="+finalIfFalse)
            finalStates.addAll(computeSTS(finalIfFalse, i.ifFalse))
        }
        finalStates
    }
    
    /*
     * - computeSTS for a ChooseBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseBehavior c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            finalStates.addAll(computeSTS(startState, b))
        }
        finalStates
    }

    /*
     * - computeSTS for a ChooseProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ChooseProtocol c){
        var ArrayList<Integer> finalStates = newArrayList()
        for (b : c.branches) {
            finalStates.addAll(computeSTS(startState, b))
        }
        finalStates
    }
        
    /*
     * - computeSTS for a RepeatBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatBehavior r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            if (final != startState) {
                var IOstsTransition t = new IOstsTransition(final,startState)
                t.setComment("Repeat loop")
                currentProcess.addTransition(t)
                //System.out.println("Added repeat transition: from="+final+", to="+startState)
            }
        }
        // add a transition with guard "false" and action "tau" from startState
        // to avoid bypassing or exiting the repeat loop.
        val int ifFalseAfterRepeat=currentProcess.newState()
        var IOstsTransition ifFalse = new IOstsTransition(startState,ifFalseAfterRepeat)
        ifFalse.setGuard("false")
        ifFalse.setComment("IfFalse avoids exit from Repeat")
        currentProcess.addTransition(ifFalse)
        //System.out.println("Added ifFalse transition after Repeat: from="+startState+", to="+ifFalseAfterRepeat)
        newArrayList(ifFalseAfterRepeat)
    }
    

    /*
     * - computeSTS for a RepeatProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RepeatProtocol r){
        var ArrayList<Integer> finalStates = newArrayList()
        // compute STS of repeated behavior, then get its final states
        finalStates.addAll(computeSTS(startState, r.repeated))
        // add a transition from each finalState to initial startState
        for (final : finalStates) {
            if (final != startState) {
                var IOstsTransition t = new IOstsTransition(final,startState)
                t.setComment("Repeat loop")
                currentProcess.addTransition(t)
                //System.out.println("Added repeat transition: from="+final+", to="+startState)
            }
        }
        newArrayList(startState) 
    }
        
    /*
     * - computeSTS for a AskAssertion statement:
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, AssertProtocol r){
    	computeSTS(startState, r.assertion)
    }
    def dispatch ArrayList<Integer> computeSTS(int startState, AssertBehavior r){
    	computeSTS(startState, r.assertion)
    }
    def dispatch ArrayList<Integer> computeSTS(int startState, AskAssertion r){
    	val final=currentProcess.newState()
        var IOstsTransition ask = new IOstsTransition(startState,final)
        ask.setGuard(r.expression.compile.toString)
        ask.setComment("AskAssertion")
        currentProcess.addTransition(ask)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for a TellAssertion statement
     * 
     *   FIXME: For the moment, we only allow expression in the form "var = expr"
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, TellAssertion r){
    	val final=currentProcess.newState()
        var IOstsTransition tell = new IOstsTransition(startState,final)
        //tell.setGuard(r.expression.compile.toString)
        tell.setComment("TellAssertion")
        // Now the tricky part! At the moment, we only recognize and handle this case:
        // - case1: the expression is "envvar = expr"
        // else, the assignment is left empty!
        if (r.expression instanceof BinaryExpression) {
        	val BinaryExpression e = (r.expression as BinaryExpression)
        	if (e.getLeft instanceof IdentExpression) {
        		val String varName = e.getLeft.compile.toString
        	    if (e.op == '=') {
        	    	// case 1
        			tell.addAssignment(varName+" := "+e.getRight().compile)
        			// register the varName as a global variable
        			var String typeName = "integer /* FIXME! should be type of assigned expression! */"
        			currentProcess.addGlobal(varName, typeName)
        		}
        	}
        }
        currentProcess.addTransition(tell)
        newArrayList(final)
    }
    
    /*
     * - computeSTS for an UntellAssertion statement
     * 
     *   TODO!
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, UntellAssertion r){
    	val final=currentProcess.newState()
        var IOstsTransition untell = new IOstsTransition(startState,final)
        untell.setComment("FIXME: UntellAssertion in not implemented!")
        System.err.println("FIXME: untell not implemented!")
	    currentProcess.addTransition(untell)
        newArrayList(final)
    }
    
    
    /*
     * - computeSTS for a ForEachBehavior statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachBehavior r){
        lastForEachVarNumber++
        val String iName = "i"+lastForEachVarNumber+"_"
        val String setOfValues = r.setOfValues.compile.toString
        val String variable = r.variable
        currentProcess.addVariable(iName)
        // transition: initialize i
        val finalInit=currentProcess.newState()
        var IOstsTransition init = new IOstsTransition(startState,finalInit)
        init.setComment("ForEachBehavior: init "+iName)
        init.addAssignment(iName+" := "+0)
        currentProcess.addTransition(init)
        // transition: if (i < sizeof(setOfValues))
        val finalIfInf=currentProcess.newState()
        var IOstsTransition ifInf = new IOstsTransition(finalInit, finalIfInf)
        ifInf.setComment("ForEachBehavior: begin loop")
        ifInf.setGuard(iName+" <= "+setOfValues+"::size()")
        ifInf.addAssignment(variable+" := "+setOfValues+"::element("+iName+")")
        currentProcess.addTransition(ifInf)
        // transitions of the Behavior inside the ForEachBehavior
        var ArrayList<Integer> endOfLoop = newArrayList()
        endOfLoop.addAll(computeSTS(finalIfInf, r.repeated))
        // transition(s) from end(s) of Behavior inside the ForEachBehavior to init
        /* alt1 */
        for (e : endOfLoop) {
        	var IOstsTransition increment = new IOstsTransition(e,finalInit)
        	increment.addAssignment(iName+" := "+iName+"+1")
        	increment.setComment("ForEachBehavior: end loop with increment")
        	currentProcess.addTransition(increment)
        }
        // end of alt1
        /* alt2
 		// add a concatenation if body ends with multiple states
        var int finalEndOfLoop
        if (endOfLoop.length > 1) {
        	finalEndOfLoop = currentProcess.newState()
        	// adding concatenations to get a unique final state for the body of ForEach
        	for (e : endOfLoop) {
	        	var IOstsTransition concatenation = new IOstsTransition(e,finalEndOfLoop)
	        	concatenation.setComment("ForEachBehavior: concatenation before increment")
	        	currentProcess.addTransition(concatenation)
	        }
        } else {
        	finalEndOfLoop = endOfLoop.get(0)
        }
        // increment
        var IOstsTransition increment = new IOstsTransition(finalEndOfLoop,finalInit)
        increment.addAssignment(iName+" := "+iName+"+1")
        increment.setComment("ForEachBehavior: end loop increment")
        currentProcess.addTransition(increment)
        // end of alt2
        */
        // transition: if (i > sizeof(setOfValues))
        val finalIfSup=currentProcess.newState()
        var IOstsTransition ifSup = new IOstsTransition(finalInit, finalIfSup)
        ifSup.setComment("ForEachBehavior: after foreach loop")
        ifSup.setGuard(iName+" > "+setOfValues+"::size()")
        currentProcess.addTransition(ifSup)
    	newArrayList(finalIfSup)
    }
    
    /*
     * - computeSTS for a ForEachProtocol statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, ForEachProtocol r){
		lastForEachVarNumber++
        val String iName = "i"+lastForEachVarNumber+"_"
        val String setOfValues = r.setOfValues.compile.toString
        val String variable = r.variable
        currentProcess.addVariable(iName)
        // transition: initialize i
        val finalInit=currentProcess.newState()
        var IOstsTransition init = new IOstsTransition(startState,finalInit)
        init.setComment("ForEachProtocol: init "+iName)
        init.addAssignment(iName+" := "+0)
        currentProcess.addTransition(init)
        // transition: if (i < sizeof(setOfValues))
        val finalIfInf=currentProcess.newState()
        var IOstsTransition ifInf = new IOstsTransition(finalInit, finalIfInf)
        ifInf.setComment("ForEachProtocol: begin loop")
        ifInf.setGuard(iName+" <= "+setOfValues+"::size()")
        ifInf.addAssignment(variable+" := "+setOfValues+"::element("+iName+")")
        currentProcess.addTransition(ifInf)
        // transitions of the Behavior inside the ForEachProtocol
        var ArrayList<Integer> endOfLoop = newArrayList()
        endOfLoop.addAll(computeSTS(finalIfInf, r.repeated))
        // transition(s) from end(s) of Behavior inside the ForEachBehavior to init
        /* alt1 */
        for (e : endOfLoop) {
        	var IOstsTransition increment = new IOstsTransition(e,finalInit)
        	increment.addAssignment(iName+" := "+iName+"+1")
        	increment.setComment("ForEachProtocol: end loop with increment")
        	currentProcess.addTransition(increment)
        }
        // end of alt1
        /* alt2
 		// add a concatenation if body ends with multiple states
        var int finalEndOfLoop
        if (endOfLoop.length > 1) {
        	finalEndOfLoop = currentProcess.newState()
        	// adding concatenations to get a unique final state for the body of ForEach
        	for (e : endOfLoop) {
	        	var IOstsTransition concatenation = new IOstsTransition(e,finalEndOfLoop)
	        	concatenation.setComment("ForEachProtocol: concatenation before increment")
	        	currentProcess.addTransition(concatenation)
	        }
        } else {
        	finalEndOfLoop = endOfLoop.get(0)
        }
        // increment
        var IOstsTransition increment = new IOstsTransition(finalEndOfLoop,finalInit)
        increment.addAssignment(iName+" := "+iName+"+1")
        increment.setComment("ForEachProtocol: end loop increment")
        currentProcess.addTransition(increment)
        // end of alt2
        */
        // transition: if (i > sizeof(setOfValues))
        val finalIfSup=currentProcess.newState()
        var IOstsTransition ifSup = new IOstsTransition(finalInit, finalIfSup)
        ifSup.setComment("ForEachProtocol: after foreach loop")
        ifSup.setGuard(iName+" > "+setOfValues+"::size()")
        currentProcess.addTransition(ifSup)
    	newArrayList(finalIfSup)
    }
    
    /*
     * - computeSTS for an AnyAction statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, AnyAction a){
        val gateOrDutyName = getNameOfGateOrDuty(a)
        val processConnectionsMap = new LinkedHashMap(currentSystem.connectionsMap.filter[p1, p2|p1.contains(gateOrDutyName+"::")])
        val choose = newChooseProtocolActionFromConnections(processConnectionsMap)
        computeSTS(startState, choose)
    }
    
    /*
     * - computeSTS for a Done statement.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, DoneProtocol r){
        // do nothing!
        newArrayList(startState)
    }
    def dispatch ArrayList<Integer> computeSTS(int startState, DoneBehavior r){
        // do nothing!
        newArrayList(startState)
    }
    
    /*
     * - computeSTS for a RecursiveCall statement.
     *   same as Repeat of entire Behavior: loop to initial state
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, RecursiveCall r){
        if (startState != 0) {
            var IOstsTransition t = new IOstsTransition(startState,0)
            t.setComment("Recursive call")
            currentProcess.addTransition(t)
            newArrayList(0) 
        }
    }    

	/*
     * - computeSTS for a Unobservable statement.
     * 
     * FIXME! At this time, we generate a transition without guard and action.
     */
    def dispatch ArrayList<Integer> computeSTS(int startState, UnobservableBehavior u){
    	val final=currentProcess.newState()
        var IOstsTransition unobservable = new IOstsTransition(startState,final)
        unobservable.setComment("FIXME: UnobservableBehavior in not implemented!")
        System.err.println("FIXME: unobservable not implemented!")
	    currentProcess.addTransition(unobservable)
        newArrayList(final)
    }
    
    //=========================== Utility functions for handling IoSTS types
    
    def getIOstsType(String name) {
    	var IOstsType result = null
    	if (name == 'integer') {
    		result = new IOstsIntType()
    		if (DEBUG) {
	    		System.err.println("getIOstsType: type '"+name+"' found: predefined.")
	    	}
    	}
    	if (result == null && currentTypesMap != null) {
    		result = currentTypesMap.get(name)
    		if (result != null) {
    			if (DEBUG) {	
    				System.err.println("getIOstsType: type '"+name+"' found in currentTypesMap.")
    			}	
	    	} else {
	    		if (DEBUG2) {
	    			System.err.println("getIOstsType: type '"+name+"' NOT found in currentTypesMap.")
	    		}
	    	}
	    }
	    if (result == null && currentSystem != null) {
            if (currentSystem.typesMap.containsKey(name)) {
                result = currentSystem.typesMap.get(name)
                if (result != null) {
	    			if (DEBUG) {
	    				System.err.println("getIOstsType: type '"+name+"' found in currentSystem.typesMap.")
	    			}
	    		} else {
	    			if (DEBUG2) {
	    				System.err.println("getIOstsType: type '"+name+"' NOT found in currentSystem.typesMap.")
	    			}
	    		}
            }
        }
        if (result == null) {
        	result = getIOstsType(name, currentLibrary)
        	// If found, put it in currentLibrary.typesMap to accelerate further searches
        	if (result != null && !currentLibrary.typesMap.containsKey(name)) {
        		currentLibrary.addType(name, result)
        	}
        }
        result
	}
	
	/*
	 * Returns the name's IOstsType if found in the given library.
	 * The search is recursive, which means imported libraries are also checked.
	 */
	def IOstsType getIOstsType(String name, IOstsLibrary library) {
		var IOstsType result = null
		if (library.typesMap.containsKey(name)) {
            result = library.typesMap.get(name)
    		if (result != null && DEBUG) {
    			System.err.println("getIOstsType: type '"+name+"' found in library '"+library.name+"'.typesMap.")
    		}
        }
        if (result == null) {
        	for (lib : library.importedMap.values) {
        		if (result == null) {
        			result = getIOstsType(name, lib)
        		}
        	}
        }
        result
	}
	
	/*
	def finalNameOfIOstsType(String name) {
	    val IOstsType t = getIOstsType(name)
	    val finalName = if (t == null) {
	        if (DEBUG2) System.err.println("Warning: Type '"+name+"' not found! Assuming integer...")
	        (new IOstsIntType()).toString
	    } else switch t {
	        IOstsIntType: t.toString
	        IOstsBoolType: t.toString
	        default: name
	    }
	    if (DEBUG2) System.out.println("Final type name '"+name+"' = '"+finalName+"'.")
	    finalName
	}
	*/
	
	/*
	 * Returns the name of the given IOstsType found in the different maps:
	 * 1) currentTypesMap, 2) currentSystem.typesMap,
	 * 3) currentLibrary.typesMap, 4) currentLibrary.importedMap
	 * If not found, returns the type.toString
	 *  
	 */
	def nameOfIOstsType(IOstsType type) {
		var name=""
		if (type instanceof IOstsNamedType) {
			name=type.toString
		}
		if (name == "" && currentTypesMap != null) {
			for (t : currentTypesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            }
    	}
	    if (name == "" && currentSystem != null) {
            for (t : currentSystem.typesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            }
        }
        if (name == "") {
        	for (t : currentLibrary.typesMap.entrySet) {
                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
                if (t.value.equals(type)) {
                    name=t.key
                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
                } else {
                    if (DEBUG2) System.out.println("KO.")
                }
            } 
        }
        if (name == "") {
        	for (lib : currentLibrary.importedMap.values) {
        		for (t : lib.typesMap.entrySet) {
	                if (DEBUG2) System.out.print("comparing '"+type.toString+"' with '"+t.value.toString+"' : ")
	                if (t.value.equals(type)) {
	                    name=t.key
	                    if (DEBUG2) System.out.println("ok, name='"+name+"'")
	                } else {
	                    if (DEBUG2) System.out.println("KO.")
	                }
            	}	
        	}
        }
        if (name == "") {
            name=type.toString()
        }
        name
	}
	
//	/*
//	 * Computing Integer values when possible
//	 * Remember that the type systems consider every integer is a Java BigInteger!
//	 */
//	def dispatch BigInteger evaluateIntegerExpression(Expression e) {
//		switch e {
//			IntegerValue: (e as IntegerValue).evaluateIntegerExpression
//			UnaryExpression: (e as UnaryExpression).evaluateIntegerExpression
//			BinaryExpression: (e as BinaryExpression).evaluateIntegerExpression
//			//TODO? IdentExpression
//			//TODO? CallExpression
//			//TODO? MethodCall
//			//TODO? Field
//			default: {
//				System.err.println("evaluateIntegerExpression: cannot evaluate expression: '"+e.compile+"'... returning 0!")
//				BigInteger.ZERO
//			}
//		}
//	}
	
//	def dispatch BigInteger evaluateIntegerExpression(IntegerValue e) {
//		new BigInteger(e.absInt.toString)
//	}
	
//	def dispatch BigInteger evaluateIntegerExpression(UnaryExpression e) {
//		val right = evaluateIntegerExpression(e.right)
//		switch e.op {
//			case '+': right
//			case '-': right.negate
//			default: {
//				System.err.println("evaluateIntegerExpression: unknown unary operator in expression: '"+e.compile+"'... returning 0!")
//				BigInteger.ZERO
//			}
//		}
//	}
	
//	def dispatch BigInteger evaluateIntegerExpression(BinaryExpression e) {
//		val left = evaluateIntegerExpression(e.left)
//		val right = evaluateIntegerExpression(e.right)
//		switch e.op {
//			case '+': left.add(right)
//			case '-': left.add(right.negate)
//			case '*': left.multiply(right)
//			case '/': left.divide(right)
//			case 'mod': left.mod(right)
//			case 'div': left.divide(right)
//			default: {
//				System.err.println("evaluateIntegerExpression: unknown binary operator in expression: '"+e.compile+"'... returning 0!")
//				BigInteger.ZERO
//			}
//		}
//	}
	
	/*
	 * IOstsType computeIOstsType(DataType t)
	 * returns an IOstsType out of the given DataType t  
	 */
	def dispatch IOstsType computeIOstsType(DataType t) {
	    switch t {
	        IntegerType: computeIOstsType(t)
	        SequenceType: computeIOstsType(t)
	        TupleType: computeIOstsType(t)
	        RangeType: computeIOstsType(t)
	        NamedType: computeIOstsType(t)
	        BooleanType: computeIOstsType(t)
	        default: {
	            var tstr=t.compile.toString
	            if (tstr.empty) tstr = t.class.name
	            System.err.println("BUG! computeIOstsType of this datatype '"+tstr+"' is not implemented! Assuming 'integer'...")
                new IOstsIntType()
	        }
	    }
	}
	
	
	def dispatch IOstsType computeIOstsType(IntegerType t) {
        new IOstsIntType()
    }
    
	def dispatch IOstsType computeIOstsType(SequenceType t) {
        // TODO: a relire et a tester !!!
        var String typeName = nameOfIOstsType(computeIOstsType(t.type))
        var IOstsType sequence = new IOstsSequenceType(new IOstsNamedType(typeName))
        sequence.setComment("sequence{"+typeName+"}")
        sequence
    }
	
	def dispatch IOstsType computeIOstsType(TupleType t) {
        var LinkedHashMap<String,IOstsType> fieldsMap=new LinkedHashMap()
        var comment="tuple{"
        var first=true
        for (f:(t as TupleType).fields) {
            val tn=f.type.compile.toString
            val _tt=computeIOstsType(f.type)
            val IOstsType tt = if (_tt instanceof IOstsIntType || _tt instanceof IOstsBoolType) _tt else new IOstsNamedType(tn)
            fieldsMap.put(f.name, tt)
            comment=comment.concat((if (first) "" else ",")+f.name+":"+tn)
            first=false
        }
        comment=comment.concat("}")
        var tuple=new IOstsTupleType(fieldsMap)
        tuple.setComment(comment)
        tuple
    }
    
    def dispatch IOstsType computeIOstsType(RangeType t) {
        new IOstsRangeType(t.vmin, t.vmax)
    }
    
    def dispatch IOstsType computeIOstsType(BooleanType t) {
    	new IOstsBoolType()
    }
    
    def dispatch IOstsType computeIOstsType(NamedType t) {
    	computeIOstsType(t.name as String)
    }
    
    
    def dispatch IOstsType computeIOstsType(String t) {
    	var result1 = getIOstsType(t)
    	if (result1 == null) {
    		//System.err.println("Warning! Type '"+t+"' is not declared! Assuming 'integer'...")
            //result1=new IOstsIntType()
            System.err.println("Warning! Type '"+t+"' is not declared!")
            result1=new IOstsNamedType(t)
        } else {
        	if (DEBUG) System.err.println("Type '"+t+"' found. ok.")
    	}
    	result1
    }
    
}

//-------------- 
// IoSTS classes
//-------------- 

//-------------- IoSTS types and functions

/*
 * Function, has:
 * 
 * - name
 * - type: the return type
 * - dataName: name of data to which the function applies
 * - dataTypeName: name's type of data to which the function applies
 * - list of formal parameters
 * - a list of Valuing
 * - a return expression
 */
class IOstsFunction {
	val String name
	var String dataName = ""
	var IOstsType dataType = null
	var LinkedHashMap<String,IOstsType> formalParameters = new LinkedHashMap()
	var ArrayList<Valuing> valuings = newArrayList()
	var Expression returnExpression = null
	var IOstsType returnType = null
	
	// private thus inaccessible, because one cannot create function without name
    private new() {
    	name = ""
    }
    
	// constructor and name
	new(String name) {
		this.name = name
	}

	def name() {
		this.name
	}
	
	// data on which the function applies
	def setData(String name, IOstsType type) {
		this.dataName = name
		this.dataType = type
	}
	
	def getDataName() {
		this.dataName
	}
	
	def getDataType() {
		this.dataType
	}
	
	// formal parameters
	def addFormalParameter(String name, IOstsType type) {
		this.formalParameters.put(name, type)
	}
	
	def formalParameter() {
		this.formalParameters
	}
	
	def getFormalParameterType(String name) {
		this.formalParameters.get(name)
	}
	
	// list of valuings
	def addValuing(Valuing v) {
		this.valuings.add(v)
	}
	
	def valuings() {
		this.valuings
	}
	
	// return type and expression
	def setReturnType(IOstsType type) {
		this.returnType = type
	}
	
	def returnType() {
		this.returnType
	}
	
	def setReturnExpression(Expression e) {
		this.returnExpression = e
	}
	
	def returnExpression() {
		this.returnExpression
	}
}

/*
 * List of IOstsFunctions
 */
class IOstsListOfFunctions extends ArrayList<IOstsFunction> {
	
	new() {
		super()
	}
	
	def addFunction(IOstsFunction f) {
    	this.add(f)
    }
    
    def getFunction(String name) {
    	var IOstsFunction result=null
    	var i=0
    	while (i < this.length && result==null) {
    		if (this.get(i).name.equals(name)) {
    			result = this.get(i)
    		}
    	}
    	result
    }
}

/*
 * Type: is the superclass of all types.
 */
class IOstsType {
    var String comment=""
    var IOstsListOfFunctions functions = new IOstsListOfFunctions()
    
    def setComment(String comment) {
        this.comment = comment
    }
   
    def comment() {
        this.comment
    }
    
    def functions() {
    	this.functions
    }
    
    def boolean equals (IOstsType other) {
        switch other {
            IOstsIntType: this.equals(other)
            IOstsBoolType: this.equals(other)
            IOstsRangeType: this.equals(other)
            IOstsTupleType: this.equals(other)
            IOstsSequenceType: this.equals(other)
            IOstsNamedType: this.equals(other)
            default: this.equals(other)
        }
    }
}

class IOstsIntType extends IOstsType {
    
    new() {}
    
    override def String toString() {
        "integer"
    }
    
    override def equals(IOstsType other) {
        (other instanceof IOstsIntType)
    }
}

class IOstsBoolType extends IOstsType {
    
    new() {}
    
    override def String toString() {
        "boolean"
    }
    
    override def equals(IOstsType other) {
        (other instanceof IOstsBoolType)
    }
}

class IOstsRangeType extends IOstsType {
	    
    Expression min
    Expression max
    
    private def Expression newIntegerExpression(int v) {
    	val factory = SosADLFactory.eINSTANCE
    	var intValue = factory.createIntegerValue()
    	intValue.setAbsInt(Math.abs(v))
		if (v >= 0) {
			intValue
	    } else {
			var unaryExpression = factory.createUnaryExpression()
			unaryExpression.setOp('-')
			unaryExpression.setRight(intValue)
			unaryExpression
		}
    }
    
    // private thus inaccessible, because one cannot create range without min and max values
    private new() {
    	min = newIntegerExpression(0)
        max = newIntegerExpression(0)
    }
    
    new(int min, int max) {
        this.min = newIntegerExpression(min)
        this.max = newIntegerExpression(max)
    }
    
    new(BigInteger min, BigInteger max) {
        this.min = newIntegerExpression(min.intValueExact)
        this.max = newIntegerExpression(max.intValueExact)
    }
    
    new(Expression min, Expression max) {
        this.min = min
        this.max = max
    }
    
    def min() {
        this.min
    }
    
    def max() {
        this.max
    }
    
    override def String toString() {
    	//"integer{"+min+".."+max+"}"
        var SosADLPrettyPrinterGenerator gen = new SosADLPrettyPrinterGenerator()
    	
    	if (SosADL2IOSTSGenerator.DEBUG) {	
	    	if (min == null) {
	    		System.err.println("IOstsRangeType: null min!")
	    	} else {
	    		System.err.println("IOstsRangeType: min.compile='"+gen.compile(min)+"'")
	    	}
	    	if (max == null) {
	    		System.err.println("IOstsRangeType: null max!")
	    	} else {
	    		System.err.println("IOstsRangeType: max.compile='"+gen.compile(max)+"'")
	    	}
    	}
    	"integer{"+gen.compile(min)+".."+gen.compile(max)+"}"
    }
	
	override def equals(IOstsType other) {
        if (other instanceof IOstsRangeType) {
            (other.min.equals(min)) && (other.max.equals(max))
        } else {
            false
        }
    }
}

class IOstsTupleType extends IOstsType {
    
    public val LinkedHashMap<String,IOstsType> fieldsMap   // map of (name -> type)
    
    // private thus inaccessible, because one cannot create tuple without fields
    private new() {
        fieldsMap = new LinkedHashMap() 
    }
    
    new(LinkedHashMap<String,IOstsType> listOfFields) {
        fieldsMap = listOfFields
    }
    
    override def String toString() {
        "tuple{"+ fieldsMap.entrySet.map[key+":"+value.toString].join(",") +"}"
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsTupleType) {
            if (other.fieldsMap.size != fieldsMap.size)
                false
            else {
                var boolean ok1=true
                val size=this.fieldsMap.size
                val ArrayList<Entry<String,IOstsType>> fields1 = newArrayList(this.fieldsMap.entrySet)
                val ArrayList<Entry<String,IOstsType>> fields2 = newArrayList(other.fieldsMap.entrySet)
                var i=0
                while(i < size) {
                    val ok2 = ((fields1.get(i).key == fields2.get(i).key) && (fields1.get(i).value.equals(fields2.get(i).value)))
                    ok1 = (ok1 && ok2)
                    i = i+1
                }
                ok1
            }
        } else false
    }
}

class IOstsSequenceType extends IOstsType {
    
    val IOstsType type
    
    // private thus inaccessible, because one cannot create array without size
    private new() {
        type = new IOstsIntType()
    }
    
    new(IOstsType type) {
        this.type = type
    }
    
    override def String toString() {
        "sequence{"+type.toString+"}"
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsSequenceType) {
            other.type.equals(type)
        } else {
            false
        }
    }
}


class IOstsNamedType extends IOstsType {
    
    val String name
    
    new(String name) {
        this.name = name
    }
    
    override def String toString() {
        name
    }
    
    override def equals(IOstsType other) {
        if (other instanceof IOstsNamedType) {
            other.name == name
        } else {
            false
        }
    }
}

//-------------- Connection, Transition, Process and IOstsSystem

/*
 * Connection
 * 
 * Notes:
 * - name, type, and mode are required at creation time, and immutable.
 * - connections in IOSTS and in SoS-ADL are identical.
 * - now, the mode of IoSTS's connection are the same as in SoSADL: 'in', 'out', 'inout'.
 */
class IOstsConnection {
    val String name
    val String typeName
    val String mode // FIXME! enum au lieu de string!
    
    new(String name, String typeName, String mode) {
        this.name=name
        this.typeName=typeName
        this.mode=mode
    }
    
    def name() {
        this.name
    }
    
    def typeName() {
        this.typeName 
    }
    
    def mode() {
        this.mode
    }
    
    override def String toString() {
        switch mode {
            case "in":
                "  "+name+"("+typeName+");\n"
            case "out":
                "  "+name+"("+typeName+");\n"
            case "inout":
                "  "+name+"("+typeName+");\n"+
                "  "+name+"("+typeName+");\n"
        } 
    }
    
}


/*
 * A IOstsTransition
 * 
 * Note:
 * - fromState and toState are immutable and must be set at creation time.
 * - guard and assignments are optional, thus mutable.
 * - action is mutable thought it is required (tau by default):
 *   this is because it can be initialized after creation.
 *   Note: in the first transition, no sync is allowed.
 * - a comment helps to understand the transformation from SoDADL to IOSTS
 */
class IOstsTransition {
	val int fromState
	val int toState
	var boolean init
	String comment=""
	String guard = "" // optional
	String action = "unobservable" // default action is unobservable
	List<String> assignments = newArrayList // optional

	new(int fromState, int toState) {
		this.fromState = fromState
		this.toState = toState
		this.init = false
	}

	def setInit(boolean init) {
		this.init = init
		if (init && guard.empty) {
			guard = "true" // default value for the init transition
		}
	}
	
	def fromState() {
		fromState
	}
	
	def toState() {
		toState
	}

	def setComment(String comment) {
		this.comment = comment
	}

	def setGuard(String guard) {
		this.guard = guard
	}

	def setAction(String action) {
		if (init) {
			System.err.println("Warning! Init transition does not admit action! Ignoring action...")
		} else {
			this.action = action
		}
	}

	def addAssignment(String statement) {
		if (init) {
			System.err.println("Warning! Init transition does not admit statement! Ignoring action...")
		} else {
			assignments.add(statement)
		}
		
	}

	override def String toString() {
		if (init) {
		'''
			from s«fromState» «IF !comment.empty»// «comment»«ENDIF»
			    guard {
			    	«guard»
			    }
			to s«toState»
		'''
		} else {
		'''
			from s«fromState» «IF !comment.empty»// «comment»«ENDIF»
			    «IF !guard.empty»
			    guard {
			    	«guard»
			    }
			    «ENDIF»
			  	action {
			  		«action»
			  	}
			  	«IF assignments.length > 0»
			  	assignments {
			  	    «assignments.join(",\n")»
			  	}
			  	«ENDIF»
			to s«toState»
		'''
		}
	}
}

/*
 * A IOstsProcess
 * 
 * Note:
 * - has an immutable name, which is required at creation time.
 * - inputMap, outputMap, and parametersMap are mutable maps of input, output of the Process.
 * - inoutputMap is a map that lives only during the translation from SoS-ADL to IOSTS
 *   because SOS-ADL has inout connections.
 * - parametersMap, and variablesMap are mutable maps containing parameters and variables of the process.
 * - globalsMap is a mutable map containing global variables used in the process.
 * - transitions is the mutable list of the transitions.
 * - lastState is an int used internally to assign names to states.
 * - lastParameterNumber is an int used internally to assign names to parameters.
 * - a comment helps to understand the transformation from SoDADL to IOSTS.
 */
class IOstsProcess{
    val String name
    var String comment=""
    public var inputMap = new LinkedHashMap()    // map of (in connection -> type name)
    public var outputMap = new LinkedHashMap()   // map of (out connection -> type name)
    public var inoutputMap = new LinkedHashMap() // map of (inout connection -> type name)
    public var parametersMap = new LinkedHashMap()  // map of (received variable -> type name)
    public var globalsMap = new LinkedHashMap()  // map of (global variable -> type name) 
    public var variablesMap = new LinkedHashMap()  // map of (variable -> type name) 
    public var List<IOstsTransition> transitions = newArrayList()
    var int lastState = 0 // number of the last state, starting at 0.
    var int lastParameterNumber = 0  // number of the last generated parameter

    new(String name) {
        this.name=name
    }
    
    def String name() {
        this.name
    }
    
    def setComment(String comment) {
        this.comment = comment
    }
        
    def addInput(String name, String typeName) {
        this.inputMap.put(name, typeName)
    }
    
    def addOutput(String name, String typeName) {
        this.outputMap.put(name, typeName)
    }
    
    def addInoutput(String name, String typeName) {
        this.inoutputMap.put(name, typeName)
    }
    
    def addParameter(String name, String typeName) {
        this.parametersMap.put(name, typeName)
    }
    
    def addGlobal(String name, String typeName) {
    	if (this.variablesMap.containsKey(name)) {
    		System.err.println("Warning! Global var '"+name+"' is already declared as local variable! Ignoring...")
        }
        else if (this.globalsMap.containsKey(name)) {
    		if (! this.globalsMap.get(name).equals(typeName)) {
    			System.err.println("Warning! Global var '"+name+"' is already declared with type '"+this.globalsMap.get(name)+"'! Ignoring...")
    		} // else: global variable 'name' is already declared with same type: ok.
    	} else {
    		this.globalsMap.put(name, typeName)	
    	}
    }
    
    def addGlobal(String name) {
        addGlobal(name, new IOstsIntType().toString)
    }
    
    def addVariable(String name, String typeName) {
        this.variablesMap.put(name, typeName)
    }
    
    def addVariable(String name) {
        addVariable(name, new IOstsIntType().toString)
    }
    
    /*
     * addTransition(transition):
     * - if a transition with same fromState and toState exists, then remove it from the transitions.
     * - adds transition to the list of transitions.
     * - updates lastState with fromState (resp. finalState) in case lastState < fromState (resp. finalState)
     */
    def addTransition(IOstsTransition transition) {
    	if (this.transitions.empty) {
    		transition.setInit(true)
    	}
    	if (this.transitions.exists[fromState() == transition.fromState() && toState() == transition.toState()]) {
    		val t = this.transitions.findFirst[fromState() == transition.fromState() && toState() == transition.toState()]
    		this.transitions.remove(t)
    	}
    	this.transitions.add(transition)	
    	if (this.lastState < transition.fromState()) {
    		this.lastState = transition.fromState()
    	}
    	if (this.lastState < transition.toState()) {
    		this.lastState = transition.toState()
    	}
    }
    
    def getTransition(int startState, int finalState) {
    	this.transitions.findFirst[fromState() == startState && toState() == finalState]
    }
    
    /*
     * Returns a new unused state id 
     */
    def int newState() {
        this.lastState = this.lastState+1
        this.lastState
    }
    
    def lastState() {
        this.lastState
    }
    
    /*
     * Returns a new unused parameter name
     */
    def newParameter() {
        this.lastParameterNumber = this.lastParameterNumber+1
        this.lastParameter()
    }
    
    def lastParameter() {
        this.name+"_p"+this.lastParameterNumber
    }
        
    override def String toString()'''
    {
    	«IF !parametersMap.empty»
    	messages {
    		«FOR p:parametersMap.keySet»
    		«p» : «parametersMap.get(p)» 
    		«ENDFOR»
    	}
    	«ENDIF»
    	«IF !globalsMap.empty»
    	globals {
    		«FOR g:globalsMap.entrySet»
    		«g.key» : «g.value»
    		«ENDFOR»
    	}
    	«ENDIF»
    	«IF !variablesMap.empty»
    	variables {
    		«FOR v:variablesMap.entrySet»
    		«v.key» : «v.value»
    		«ENDFOR»
    	}
    	«ENDIF»
    	states {
    		init{s0}«FOR s:1..lastState» s«s»«ENDFOR»
    	}
    	transitions {
    		«FOR t:transitions»
    		«t.toString»
    		
    		«ENDFOR»
    	}
    }
    '''
}

/*
 * IOstsSystem
 * 
 * Notes:
 * - has an immutable name, which is required at creation time.
 * - fileName is the name of the file to be saved.
 * - connectionsMap is the map of all gates or duties connections declared in this system 
 * - constantsMap is not used at this time.
 * - typesMap is a mutable map containing the declaration of all types used in this system.
 * - processesMap is the map of processes of this system.
 * - a comment helps to understand the transformation from SoDADL to IOSTS.
 * It is possible to get allConnections declared inside gate/duty of this system. 
 */
class IOstsSystem{
    val String name
    var String comment=""
    //OLD version: not needed anymore: var String behaviorName="UNDEFINED"
    public var LinkedHashMap<String,IOstsConnection> connectionsMap = new LinkedHashMap()  // map of (connection name -> Connection)
    public var LinkedHashMap<String,String> constantsMap = new LinkedHashMap()     // map of (name -> value as tring)
    public var LinkedHashMap<String,IOstsType> typesMap = new LinkedHashMap()     // map of (name -> iosts type)
    public var LinkedHashMap<String,IOstsProcess> processesMap = new LinkedHashMap()  // map of (process name -> Process)
    
    new(String name) {
       this.name=name
    }
    
    def getName() {
    	this.name
    }
    
    def setComment(String comment) {
       this.comment = comment
    }
    
    def addAllConnections(LinkedHashMap<String,IOstsConnection> connectionsMap) {
    	this.connectionsMap.putAll(connectionsMap)
    }
    
    def addConnection(IOstsConnection connection) {
        this.connectionsMap.put(connection.name, connection)
    }
    
    def getConnection(String name) {
    	connectionsMap.get(name)
    }

    def LinkedHashMap<String,IOstsConnection> allConnections() {
    	connectionsMap
    }
    
    def addProcess(IOstsProcess process) {
        // Sometimes, for example when "behavior{done}", the sts is empty.
        // In those cases, do not add the process, because it is invalid! 
        if (process.transitions.empty) {
            System.err.println("Warning! Process '"+process.name+"' is empty! Ignoring...")
        } else {
            /* OLD version: now, there is no need anymore to distinguish protocol process from behavior process.
            if (process.name.contains("_behavior")) {
                behaviorName=process.name
            }
            */
            this.processesMap.put(process.name, process)
        }
    }
    
    /*
     * empty returns true if no process has been generated.
     */
    def empty() {
        processesMap.empty
    }
}

/*
 * IOstsLibrary
 * 
 * Notes:
 * - has an immutable name, which is required at creation time.
 * - fileName is the name of the file to be saved.
 * - importedMap is a mutable map containing the list of imported libraries
 * - typesMap is a mutable map containing the locally declared types
 * - systemsMap is a mutable map containing the locally declared systems
 * 
 * In SoSADL, SoS and Library declare the same elements (an EntityBlock).
 * Thus, after translated in IoSTS, we use an IOstsLibrary instance to store
 * all iosts types and systems coming from either an SoS or a Library.
 */
class IOstsLibrary{
    val String name
    var String fileName=""
	public var LinkedHashMap<String,IOstsLibrary> importedMap = new LinkedHashMap()  // map of (name -> imported iosts library)
    public var LinkedHashMap<String,IOstsType> typesMap = new LinkedHashMap()     // map of (name -> iosts type)
    public var IOstsListOfFunctions functions = new IOstsListOfFunctions()       // list of declared functions
    public var LinkedHashMap<String,IOstsSystem> systemsMap = new LinkedHashMap()  // map of (name -> iosts system)
    
    new(String name) {
       this.name=name
    }
    
    def name() {
    	this.name
    }
    
    def setFileName(String fileName) {
       this.fileName = fileName
    }
    
    def fileName() {
        fileName
    }
    
    // Returns all iosts imported library
    def LinkedHashMap<String,IOstsLibrary> importedLibraries() {
    	this.importedMap
    }
    
    def getImportedLibrary(String name) {
    	this.importedMap.get(name)
    }
    
    def addImportedLibrary(IOstsLibrary library) {
        this.importedMap.put(library.name, library)
    }
    
    // Returns all locally declared types
    def LinkedHashMap<String,IOstsType> types() {
    	this.typesMap
    }
    
    def getType(String name) {
    	this.typesMap.get(name)
    }
    
    def addType(String name, IOstsType type) {
        this.typesMap.put(name, type)
    }
    
    // Returns all locally declared functions
    def functions() {
    	this.functions
    }
    
    // Returns all iosts systems declared in this library
    def LinkedHashMap<String,IOstsSystem> systems() {
    	this.systemsMap
    }
    
    def getSystem(String name) {
    	this.systemsMap.get(name)
    }
    
    def addSystem(IOstsSystem system) {
        this.systemsMap.put(system.name, system)
    }
}
